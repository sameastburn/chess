package passoffTests;

import chess.*;
import org.junit.jupiter.api.Assertions;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

// SetEqualityDebugger class generated by ChatGPT temporarily to debug
// will not be included in the final solution.
class SetEqualityDebugger {
    public static <T> boolean areSetsEqual(Set<T> set1, Set<T> set2) {
        // Check for same instance
        if (set1 == set2) {
            System.out.println("Sets are the same instance.");
            return true;
        }

        // Check for null
        if (set1 == null || set2 == null) {
            System.out.println("One of the sets is null.");
            return false;
        }

        // Check if sizes are equal
        if (set1.size() != set2.size()) {
            System.out.println("Sets sizes are different.");
            System.out.println("Size of set1: " + set1.size() + ", Size of set2: " + set2.size());
            return false;
        }

        // Check if all elements of set1 are in set2
        for (T item : set1) {
            System.out.println("item in set1: " + item.toString());

            if (!set2.contains(item)) {
                System.out.println("Item from set1 not found in set2: " + item.toString());
                // return false;
            }
        }

        // Check if all elements of set2 are in set1 (optional if sets are same size)
        for (T item : set2) {
            System.out.println("item in set2: " + item.toString());

            if (!set1.contains(item)) {
                System.out.println("Item from set2 not found in set1: " + item.toString());
                // return false;
            }
        }

        System.out.println("Sets are equal.");
        return true;
    }
}

/**
 * Used for testing your code
 */
public class TestFactory {

    // Chess Functions
    // ------------------------------------------------------------------------------------------------------------------
    public static ChessBoard getNewBoard() {
        return new ChessBoard();
    }

    public static ChessGame getNewGame() {
        return new ChessGame();
    }

    public static ChessPiece getNewPiece(ChessGame.TeamColor pieceColor, ChessPiece.PieceType type) {
        return new ChessPiece(pieceColor, type);
    }

    public static ChessPosition getNewPosition(int row, int col) {
        return new ChessPosition(row, col);
    }

    public static ChessMove getNewMove(ChessPosition startPosition, ChessPosition endPosition,
                                       ChessPiece.PieceType promotionPiece) {
        return new ChessMove(startPosition, endPosition, promotionPiece);
    }
    // ------------------------------------------------------------------------------------------------------------------

    // Websocket Tests
    // ------------------------------------------------------------------------------------------------------------------
    public static Long getMessageTime() {
        /*
         * Changing this will change how long tests will wait for the server to send
         * messages.
         * 3000 Milliseconds (3 seconds) will be enough for most computers. Feel free to
         * change as you see fit,
         * just know increasing it can make tests take longer to run.
         * (On the flip side, if you've got a good computer feel free to decrease it)
         */
        return 3000L;
    }
    // ------------------------------------------------------------------------------------------------------------------

    static public ChessPosition startPosition(int row, int col) {
        return getNewPosition(row, col);
    }

    static public int[][] endPositions(int[][] endPos) {
        return endPos;
    }

    static public void validateMoves(String boardText, ChessPosition startPosition, int[][] endPositions) {
        var board = loadBoard(boardText);
        var testPiece = board.getPiece(startPosition);
        var validMoves = loadMoves(startPosition, endPositions);

        // NOTE -- MIGHT NEED TO REVERT CHANGES IN THIS FUNCTION
        // IN ORDER TO NOT FAIL FOR CHANGING TESTS(?)
        var pieceMoves = testPiece.pieceMoves(board, startPosition);

        /*
        var testMoves1 = new HashSet<ChessMove>();
        testMoves1.add(getNewMove(getNewPosition(1, 1), getNewPosition(1, 2), null));

        var testMoves2 = new HashSet<ChessMove>();
        testMoves2.add(getNewMove(getNewPosition(1, 1), getNewPosition(1, 2), null));

        var move1 = getNewMove(getNewPosition(1, 1), getNewPosition(1, 2), null);
        var move2 = getNewMove(getNewPosition(1, 1), getNewPosition(1, 2), null);

        System.out.println(move1.hashCode());
        System.out.println(move2.hashCode());

        System.out.println(move1.equals(move2));

        // Assertions.assertEquals(testMoves1, testMoves2, "Wrong moves");
        System.out.println("\ntestMoves1");
        System.out.println(testMoves1.toString());

        System.out.println("\ntestMoves2");
        System.out.println(testMoves2.toString());

        System.out.println("\ntestMoves1.equals(testMoves2)");
        System.out.println(testMoves1.equals(testMoves2));

        System.out.println("\nSetEqualityDebugger.areSetsEqual");
        boolean result = SetEqualityDebugger.areSetsEqual(testMoves1, testMoves2);
        System.out.println(result);

        Assertions.assertEquals(testMoves1, testMoves2, "Wrong moves");

        System.out.println("\nvalidMoves");
        System.out.println(validMoves.toString());

        System.out.println("\npieceMoves");
        System.out.println(pieceMoves.toString());

        System.out.println("\nvalidMoves.equals(pieceMoves)");
        System.out.println(validMoves.equals(pieceMoves));

        Set<ChessMove> pieceMovesSet =(Set<ChessMove>) pieceMoves;

        System.out.println("\nSetEqualityDebugger.areSetsEqual");
        boolean result = SetEqualityDebugger.areSetsEqual(validMoves, pieceMovesSet);
        System.out.println(result);
        */

        Assertions.assertEquals(validMoves, pieceMoves, "Wrong moves");
    }

    final static Map<Character, ChessPiece.PieceType> charToTypeMap = Map.of(
            'p', ChessPiece.PieceType.PAWN,
            'n', ChessPiece.PieceType.KNIGHT,
            'r', ChessPiece.PieceType.ROOK,
            'q', ChessPiece.PieceType.QUEEN,
            'k', ChessPiece.PieceType.KING,
            'b', ChessPiece.PieceType.BISHOP);

    public static ChessBoard loadBoard(String boardText) {
        var board = getNewBoard();
        int row = 8;
        int column = 1;
        for (var c : boardText.toCharArray()) {
            switch (c) {
                case '\n' -> {
                    column = 1;
                    row--;
                }
                case ' ' -> column++;
                case '|' -> {
                }
                default -> {
                    ChessGame.TeamColor color = Character.isLowerCase(c) ? ChessGame.TeamColor.BLACK
                            : ChessGame.TeamColor.WHITE;
                    var type = charToTypeMap.get(Character.toLowerCase(c));
                    var position = TestFactory.getNewPosition(row, column);
                    var piece = TestFactory.getNewPiece(color, type);
                    board.addPiece(position, piece);
                    column++;
                }
            }
        }
        return board;
    }

    public static Set<ChessMove> loadMoves(ChessPosition startPosition, int[][] endPositions) {
        var validMoves = new HashSet<ChessMove>();
        for (var endPosition : endPositions) {
            validMoves.add(TestFactory.getNewMove(startPosition,
                    TestFactory.getNewPosition(endPosition[0], endPosition[1]), null));
        }
        return validMoves;
    }
}
